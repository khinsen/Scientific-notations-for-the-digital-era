\section{Introduction}

Today's computing culture is focused on results. Computers and software are seen primarily as tools that get a job done. They are judged by the utility of the results they produce, by the resources (mainly time and energy) they consume, and by the effort required for their construction and maintenance. In fact, we have the same utilitarian attitude towards computers and software as towards other technical artifacts such as refrigerators or airplanes.

In scientific research, however, the path that leads to a result is as important as the result itself. Drawing conclusions from an experimental measurement requires a good understanding of the experimental setup that was used to obtain the measurement. A scientist interpreting them must know the reliability and precision of the devices that were used, and be familiar with potential artifacts that could lead to misinterpretations. Likewise, the computational results obtained from scientific software can only be interpreted with a good understanding of what exactly the software does. Scientific software therefore has the same status in science as experimental setups and theoretical models.

In scientific discourse and in particular in the evaluation of a research publication, results are therefore scrutinized together with the path that lead to them. We expect experimentalists to explain the materials and methods they have used, and theoreticians to explain their reasoning in sufficient detail that their peers can understand it. We should thus treat computational science in the same way and require scientific software to be published and scrutinized in peer review. While publication of scientific software is slowly becoming common, peer review of this software remains exceptional. Its necessity is well recognized in principle, but the effort required for such a review is prohibitive. This is the most visible symptom of the problem that is the topic of this essay. More generally, this problem is that digital scientific knowledge is today expressed using notations such as programming languages, which are not suitable for communication between human scientists.

In the following, I will present a detailed analysis of this problem, and propose some general guidelines for improving the situation. The main audience is computational scientists, who have practical experience with doing science using computers but no formal training in computer science or in scientific epistemology. Readers with a computer science background may skim over much of the second part. Note that I will not propose \textit{the} solution to the problem, nor even \textit{a} solution. My goal is to convince computational scientists that there \textit{is} a problem, and that it \textit{can} be solved. Finding solutions that work well is likely to require many years and the participation of many people willing to test different ideas in practice.

The analysis that I present is applicable to all branches of science whose models are based on continuous mathematics, such as algebraic, differential, or integral equations. This includes almost all of physics and chemistry, a good part of biology and the quantitative social sciences, and all domains of applied research that build on foundations in physics and chemistry. Much of what I say also applies to models based on discrete mathematics, such as graphs or cellular automata, but I will not consider them for the sake of simplicity. The examples I will use for illustration reflect my own background in computational biophysics, but readers shouldn't find it difficult to substitute examples from their own field of work.

\subsection*{Outline}

I start by summarizing the structure of scientific knowledge (section~\ref{scientific-knowledge}), explaining factual, procedural, and conceptual knowledge and why only the first two categories are used in computation. Next, I outline how scientific communication and the notations used for it evolved in the course of history (section~\ref{evolution}). These two sections prepare the discussion of digital scientific knowledge (section~\ref{digital}) and why we should care about it more than we do at the moment. This should provide sufficient motivation for the reader to work through the more technical section on formal languages (section~\ref{formal-languages}), a well-known concept in computer science that unifies two categories that computational scientists tend to see as distinct: file formats for data and programming languages, the two dominant forms of digital scientific notation today.

After this more theoretical part, I explain the importance of composition of information items (section~\ref{composition}) using as an example the simulation of celestial mechanics, with an emphasis on the constraints on the composition of digital knowledge (section~\ref{composition-digital}). My goal is to illustrate what one should be able to do with a proper digital scientific notation. I then compare to the state of the art (section~\ref{state-of-the-art}) in computational science, pointing out how it is inadequate for the study of complex systems (section~\ref{complex-systems}). One obstacle to improvement is a perceived dichotomy between software and data (section~\ref{software-data}), which has its roots in computing technology but has no counterpart in the structure of scientific knowledge.

An important point that is often overlooked is the status of formal languages  as the main human-computer interface (section~\ref{HCI}) in computational science. Doing research is a different task from developing software, and requires a different interface. In particular, we should pay more attention to the difference between human and computational semantics (section~\ref{HCI-semantics}) and to the need for simplicity and flexibility (section~\ref{flexibility}) of a notation suitable for humans doing creative research. Moreover, a digital scientific notation must permit precise references to the scientific record (section~\ref{sr-references}).

In the last part of this essay, I consider solution strategies for the problems that I have identified. I show two examples of how formal languages can be made simple and flexible (section~\ref{simple-and-flexible}) while providing a straightforward mechanism for composition: XML (section~\ref{XML}) with its namespace mechanism for composition, and the Lisp (section~\ref{lisp}) family of programming languages with its macro system for creating small embedded formal languages. I conclude by proposing design guidelines (section~\ref{design-guidelines}) for digital scientific notations.